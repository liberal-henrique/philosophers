Philosophers
	Vamos compilar um apanhado de conteudos para o desenvolvimento
desse projeto de maneira rapida e produtiva.

Intrucoes do subject:
- The philosophers alternatively eat, think, or sleep.
- There are as many forks as philosophers.
- Because serving and eating spaghetti with only one fork is very inconvenient, a
philosopher takes their right and their left forks to eat, one in each hand.
- Your program should take the following arguments:
number_of_philosophers time_to_die time_to_eat time_to_sleep
[number_of_times_each_philosopher_must_eat]
- To prevent philosophers from duplicating forks, you should protect the forks state
with a mutex for each of them.



Estava a assistir um video do vault sobre threads

Em conversa com o Ezequiel para hoje vale a pena
criar a lista de filosofos e limpar essa lista.
Usar o init do mutex e o destroy dentro de cada um.
Tudo isso deve estar a funcionar sem leaks.


1000 - 900 < 400
agora - ultima_refeicao < tempo_morte
agora - ultima_refeicao - tempo_morte < 0


	Em conversa com o Rubens foi-me dito que o mutex servira para trancar a variavel
quando formos acessa-la para a alteracao do seu valor. Portanto, os talheres
terao um mutex e um boolean para quando formos acessar o Boolean apenas alteremos
o mutex para lock. Dessa forma, faremos a alteracao e depois faremos o unlock e, assim,
nao havera data race. Importante perceber que nao estamos fazendo mutex para lock o acesso
a variaveis.
	Tudo que for compartilhado entre todos deve ir para a table. Exemplo o tempo de morte
que deve ser o mesmo para todo mundo.
	Temos de alternar o acesso aos talheres. Os pares comecarao comendo, pois eles irao pegar o talher
dos impares. Os impares tentaram pegar o proprio talher e alguns nao conseguiram outras sim. Os que conseguiram
serao os primeiros a comer, os que nao, irao comer depois de quem conseguiu.
	Ele criou a metafora do quarto. A variavel sera comparada a um quarto. Assim, quando
quisermos alterar o conteudo, entraremos pela porta e a trancaremos. Depois disso, alteramos
o que quiser alterar e depois  destrancamos e saimos. Isso sera usado para tudo que for aces-
sado por mais de um componente.
	Discutimos, tambem, sobre a importancia e alguns metodos de organizacao de codigo. Ele
demonstrou que a main pode contar "um narrativa" de como todo o programa se comportara.



	Eu ja tenho a lista de filosofos e cada um ja esta com seu talher.
	Ja percebi como realizar o lock e unlock desses talheres.
	Criei um mutex para cada um dos topicos que aparentemente serao
partilhados com os demais elementos do programa.

	- Precisarei criar a pthread de cada filosofo.

Pegar o talher
Alterar o mutex para locked

Apenas um talher


Comer
Um filosofo estar comendo eh ele ter acesso a dois talheres pelo tempo determinado.


Problemas para resolver no Philosophers
- O ultimo filosofo esta a ficar preso. Ele solta o garfo mas
nao esta a se movimentar mais

22/06
TO-DO
- Testar mais para perceber se onde sao os corners cases
- Pares, impares, solitarios, sanityzer, valgrind e depois o de 200
- Perceber pq o de 1 nao da free();
- Sera que todo mundo da free()

Diagnostic
- Ao correr o programa com o valgrind com 1 philo ele esta a demorar
como eh esperado e mas depois retorna todos os frees. Nao sei se essa
demora deveria ser tao grande. Em comparacao a outros trabalhos, isso esta
errado.

- Correr o programa sem valgrind e perceber o comportamento.

./philo 2 450 200 200
--> Os philos se encadearam corretamente, porem a acao de pensar ficou
confinada a um instante.

./philo 4 410 200 200
--> O philo 3 ja entrou morto. No instante 00000 ele indicou que estava morto.
Para resolver isso coloquei um ft_usleep(50) antes de iniciar o supervisor(table), pois
acredito que ele estivesse a checar tudo cedo demais.

./philo 5 800 200 200
--> A organizacao das threads nao esta a correr da forma devida, tendo em vista que estao
a morrer sem o desafios.
Pq o philo esta a ficar 400 sem comer?
Eu acredito que eles estivessem a correr aos garfos demasiado rapido. Portanto, forcei
um usleep(50) para que eles deixassem a aplicacao correr de forma mais fluida.

./philo 5 800 200 200 7
--> Os philos nao estao a quantidade de vezes suficiente. Isso esta a correr pq alguns
philos estao a morrer quando nao deveriam.



Problemas com Philosophers



